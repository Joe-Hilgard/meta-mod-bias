---
title: "Meta-Analysis"
author: "Olivia Cody"
date: "1/30/2018"
output: html_document
---

Next steps:
- better document the code (better names)
- code book (what are the object and what do they do) 

- making loop, fitting data sets, and doing it repeatly 

 




```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(MASS)
library(tidyverse)
library(truncnorm)
library(truncdist)
library(pwr)
library(compiler)
library(metafor)

# load study-simulating functions
source("sim-studies.R")
```


####*Simulate a meta-analytic dataset with dataMA()*
```{r}
dat <- dataMA(k = 50,
              QRP = 0,
              sel =0,
              sigma = 0,
              min = 50, max = 500)

# let's look at it
head(dat)

# let's fit our first meta-analysis
ma1 <- rma(yi = d, sei = se, data = dat)
summary(ma1)
funnel(ma1)
trimfill(ma1)
funnel(trimfill(ma1))
funnel(ma1, level=c(90, 95, 99), 
        shade = c("white", "grey75", "grey60"), refline=0)

```

####*Simulate a null effect*
```{r}
# simulate null effect dataset with dataMA()
dat.null <- dataMA(k = 50,
              QRP = 0,
              sel =0,
              sigma = 0,
              min = 50, max = 500,
              meanD = 0)

#meta-analysis for a null effect
ma2 = rma(yi = d, sei = se, data = dat.null)
summary(ma2)
funnel(ma2)
forest(ma2)

#same thing but using less data so we can see the forest plot
ma3 = rma(yi = d, sei = se, data = head(dat.null))
summary(ma3)
forest(ma3)
```

####*Techniques for detecting and adjusting bias*
**Ways to detect bias**
- Funnel plots
- Forest plots?
- Egger Test (looks at slope)

**Ways to detect and adjust bias**
- Trim and fill
- PET (just looks at intercept) and PEESE
- P-curve
- P-uniform

####*Simulate bias data*
```{r}
dat.bias = dataMA(k = 50,
                  QRP = 0,
                  sel =1, propB = .9, # % of each subgroup stat. sig
                  sigma = 0,
                  min = 50, max = 500,
                  meanD = 0)
ma4 = rma(yi = d, sei = se, data = dat.bias)
summary(ma4)
funnel(ma4)
funnel(ma4, refline = 0)
#refline is the vertical reference line values, set to 0 to see bias

#Test for bias: using the egger test
ma4.1 <- rma(yi = d, sei = se,
                  mods = ~se, data = dat.bias)
plot(ma4.1)
funnel(ma4.1)

#:using trim and fill to "correct" data
trimfill(ma4)
funnel(trimfill(ma4), refline = 0)

#:using PET and PEESE
petrma.easy <- modMA(100, d = c(0, 1, 2),
                QRP = 0, sel = 0, propB = 0) #does pet rma work in ideal case
petrma.add.easy <- rma(yi = d, sei = se, 
                       mods = ~ id + se, data = petrma.easy) #SE + id
summary(petrma.add.easy)
petrma.mul.easy <- rma(yi = d, sei = se, 
                       mods = ~ id * se, data = petrma.easy) #SE * id
summary(petrma.mul.easy)

petrma.bias <- modMA(100, d = c(0, 1, 2),
                     QRP = 0, sel = 1, propB = .7)
petrma.add.bias <- rma(yi = d, sei = se, 
                       mods = ~ id + se, data = petrma.bias)
summary(petrma.add.bias)
petrma.mul.bias <- rma(yi = d, sei = se, 
                       mods = ~ id * se, data = petrma.bias)
summary(petrma.mul.bias)
#:using P-curve

#:using P-uniform 

```

####*Simulate a moderator effect (meta-regression)*
```{r}
dat <- dataMA(k = 50,
              QRP = 0,
              sel =0,
              sigma = 0,
              min = 50, max = 500)
dat.mod <- data.frame(dat, "mod" = runif(50))
ma5 = rma(yi = d, sei = se, data = dat.mod,
          mods = mod)
summary(ma5)
plot(ma5)

ma6 = rma(yi = d, sei = se, data = dat.bias, mods = se)
plot(ma6)
funnel(ma4)

```


####*Code that does it all in one*
```{r}

# Function that runs dataMA three times + fake data
modMA <- function(k, d, QRP, sel, propB) {
  d1 <- dataMA(k = k, 
               QRP = QRP, sel = sel, propB = propB, 
               meanD = d[1], sigma = 0,
               cbdv = .5, maxN = 200, minN = 20,
               meanN = 50, sdN = 20,
               multDV = 0, out = 0, mod = 0,
               colLim = 0, add = 0, verbose = T)
  d2 <- dataMA(k = k, 
               QRP = QRP, sel = sel, propB = propB, 
               meanD = d[2], sigma = 0,
               cbdv = .5, maxN = 200, minN = 20,
               meanN = 50, sdN = 20,
               multDV = 0, out = 0, mod = 0,
               colLim = 0, add = 0, verbose = T)
  d3 <- dataMA(k = k, 
               QRP = QRP, sel = sel, propB = propB, 
               meanD = d[3], sigma = 0,
               cbdv = .5, maxN = 200, minN = 20,
               meanN = 50, sdN = 20,
               multDV = 0, out = 0, mod = 0,
               colLim = 0, add = 0, verbose = T)
  return(bind_rows(d1, d2, d3, .id = "id"))
}


# function to analyze results of dataMA
inspectMA <- function(dataset) {
  # basic model
  rmamod <- rma(yi = d, sei = se, data = dataset)
  # test for moderator
  moderation.test <- rma(yi = d, sei = se, 
                         mods = ~id, data = dataset)
  # test for small-study effect
  egger.PET.test <- rma(yi = d, sei = se,
                    mods = ~se, data = dataset)
  # test for moderator after adjustment for small-study
  joint.test.additive <- rma(yi = d, sei = se,
                    mods = ~id + se, data = dataset)
  joint.test.interactive <- rma(yi = d, sei = se,
                             mods = ~id * se, data = dataset)
  # not sure how to interpret these parameters in the interactive model
  # test for moderator in hedges & vevea weight model
  # return test results
  out = data.frame(d.obs = summary(rmamod)$b[1],
                    se.obs = summary(rmamod)$se[1],
                    d.p = summary(rmamod)$pval[1],
                    # Moderators
                    # Note that .1 is the intercept, reference group
                    mod.b.obs.1 = summary(moderation.test)$b[1],
                    mod.b.obs.2 = summary(moderation.test)$b[2],
                    mod.b.obs.3 = summary(moderation.test)$b[3],
                    mod.p.1 = summary(moderation.test)$pval[1],
                    mod.p.2 = summary(moderation.test)$pval[2],
                    mod.p.3 = summary(moderation.test)$pval[3],
                    # Egger / PET
                    d.obs.pet = summary(egger.PET.test)$b[1],
                    p.pet = summary(egger.PET.test)$pval[1],
                    b.egger = summary(egger.PET.test)$b[2],
                    p.egger = summary(egger.PET.test)$pval[2],
                    # joint PET-RMA tests
                    #Additive model 
                    joint.add.b1 = summary(joint.test.additive)$b[1],
                    joint.add.b2 = summary(joint.test.additive)$b[2],
                    joint.add.b3 = summary(joint.test.additive)$b[3],
                    joint.add.b.se = summary(joint.test.additive)$b[4],
                    joint.add.p1 = summary(joint.test.additive)$pval[1],
                    joint.add.p2 = summary(joint.test.additive)$pval[2],
                    joint.add.p3 = summary(joint.test.additive)$pval[3],
                    joint.add.p.se = summary(joint.test.additive)$pval[4],
                    #Interactive model
                    joint.inter.b1 = summary(joint.test.interactive)$b[1],
                    joint.inter.b2 = summary(joint.test.interactive)$b[2],
                    joint.inter.b3 = summary(joint.test.interactive)$b[3],
                    joint.inter.b.se = summary(joint.test.interactive)$b[4],
                    joint.inter.b2.se = summary(joint.test.interactive)$b[5],
                    joint.inter.b3.se = summary(joint.test.interactive)$b[6],
                    joint.inter.p1 = summary(joint.test.interactive)$pval[1],
                    joint.inter.p2 = summary(joint.test.interactive)$pval[2],
                    joint.inter.p3 = summary(joint.test.interactive)$pval[3],
                    joint.inter.p.se = summary(joint.test.interactive)$pval[4],
                    joint.inter.p2.se = summary(joint.test.interactive)$pval[5],
                    joint.inter.p3.se = summary(joint.test.interactive)$pval[6]
                    )
  return(data.frame(out))
  }

# function to make various visuals of MA: (?)

visualizeMA <- function(dataset){
  visu.data = plot(dataset)
  #output
  return(visu.data)
}


# make example data set for testing & debugging
set.seed(42069)
meta1.data <- modMA(k = 20, d = c(0, .3, .6), 
               sel = 1, propB = .70, QRP = 0)
test = inspectMA(meta1.data)
vistest = visualizeMA(meta1.data)
View(meta1.data)

#work space below:


```

####*Function output documentation*

##**inspectMA** 
if its a cell mean call it d, when its a difference call it b
*d.obs* estimated effect size between...? It says in rma that this is the beta value, so should we use b. instead? "estimated coefficents of the model"
*se.obs* standerd error of the estimate of the overall mean
*d.p* if the observed effect sizes are significantly different?
*mod.b.obs.#* estimated coefficents of the moderator
*mod.p.#* significance vaule for the moderation test, significance indicates...
*d.obs.pet*
*p.pet* significance vaule for the PET test, significance indicates...
*b.egger*
*p.egger* significance vaule for the egger test, significance indicates...
*joint.add.b#*
*joint.add.b.se* coefficient of predictor 'se'
- Be careful with the naming here -- it would be hazardous if we confuse "coefficient 'b' of predictor 'se'" with "the standard error of coefficient 'b'"
*joint.add.p#* significance vaule for coefficents for the PET-RMA (id+se) test, significance indicates...
*joint.add.p.se* significance vaule for the additive effect of the PET-RMA (id+se) test, significance indicates...
*joint.inter.b#*
*joint.inter.b#.se*
*joint.inter.p#* ignificance vaule of the coefficents for the PET-RMA (id*se) test, significance indicates...
*joint.inter.p#.se* significance vaule of the interaction for the PET-RMA (id*se) test, significance indicates...


####* r Package code*
```{r}
#Additional libraries:
library("devtools")
library("roxygen2")
#See: https://hilaryparker.com/2014/04/29/writing-an-r-package-from-scratch/


#Step 1: Create your package directory

work_dir = "/Users/Olivia/Documents/GitHub/meta-mod-bias"
setwd(work_dir)
create("meta.bias")

#If you look in your parent directory, in it you will have two folders and one file called DESCRIPTION. Need to edit the DESCRIPTION file to include all of your contact information, etc.


#Step 2: Add functions
#save funcitons as a "meta.bias.R" in the R directory 


#Step 3: Add documentation

#' A Meta-analysis Function
#'
#' This fucntion produces a dataset for meta-analysis. Applies both QRP and selection at a proportion specified by propB if sel and QRP are 1 not 0. 
#' @param k the number of studies in the MA
#' @param QRP 1 if QRP/p-hacks are available, 0 otherwise
#' @param sel 1 if publication bias selection exists, 0 otherwise
#' @param propB the proportion of the sample affected by bias
#' @param meanD the true effect (or the average of the true effects if heterogeneity exists)
#' @param sigma the SD around the true effect
#' @param cbdv the correlation between the multiple DVs
#' @param maxN the max possible group size that could be created *this needs to be set higher than what can actually be generated--it doesn't mean you get bigger samples
#' @param minN the min of the truncated normal for sample size
#' @param meanN the mean of the truncated normal for sample size
#' @param sdN the SD of the truncated normal for sample size
#' @param multDV 1 if multiple DVs as a hack, 0 otherwise
#' @param out 1 if optional outlier removal as a hack, 0 otherwise
#' @param mod 1 if optional moderator as a hack, 0 otherwise
#' @param colLim number of times to try collecting more data
#' @param add number to add to each group when collecting more data
#' @param verbose Should informations be printed?
#' dataMA()
dataMA = source("sim-studies.R")


#' A Meta-analysis Function
#'
#' This function analyzes the results of dataMA 
#' @param Q this is fake and does nothing, need help knowing what to put
#' inspectMA()
inspectMA <- function(dataset) {
  # basic model
  rmamod <- rma(yi = d, sei = se, data = dataset)
  # test for moderator
  moderation.test <- rma(yi = d, sei = se, 
                         mods = ~id, data = dataset)
  # test for small-study effect
  egger.PET.test <- rma(yi = d, sei = se,
                    mods = ~se, data = dataset)
  # test for moderator after adjustment for small-study
  joint.test.additive <- rma(yi = d, sei = se,
                    mods = ~id + se, data = dataset)
  joint.test.interactive <- rma(yi = d, sei = se,
                             mods = ~id * se, data = dataset)
  # not sure how to interpret these parameters in the interactive model
  # test for moderator in hedges & vevea weight model
  # return test results
  out = data.frame(d.obs = summary(rmamod)$b[1],
                    se.obs = summary(rmamod)$se[1],
                    d.p = summary(rmamod)$pval[1],
                    # Moderators
                    # Note that .1 is the intercept, reference group
                    mod.b.obs.1 = summary(moderation.test)$b[1],
                    mod.b.obs.2 = summary(moderation.test)$b[2],
                    mod.b.obs.3 = summary(moderation.test)$b[3],
                    mod.p.1 = summary(moderation.test)$pval[1],
                    mod.p.2 = summary(moderation.test)$pval[2],
                    mod.p.3 = summary(moderation.test)$pval[3],
                    # Egger / PET
                    d.obs.pet = summary(egger.PET.test)$b[1],
                    p.pet = summary(egger.PET.test)$pval[1],
                    b.egger = summary(egger.PET.test)$b[2],
                    p.egger = summary(egger.PET.test)$pval[2],
                    # joint PET-RMA tests
                    #Additive model 
                    joint.add.b1 = summary(joint.test.additive)$b[1],
                    joint.add.b2 = summary(joint.test.additive)$b[2],
                    joint.add.b3 = summary(joint.test.additive)$b[3],
                    joint.add.b.se = summary(joint.test.additive)$b[4],
                    joint.add.p1 = summary(joint.test.additive)$pval[1],
                    joint.add.p2 = summary(joint.test.additive)$pval[2],
                    joint.add.p3 = summary(joint.test.additive)$pval[3],
                    joint.add.p.se = summary(joint.test.additive)$pval[4],
                    #Interactive model
                    joint.inter.b1 = summary(joint.test.interactive)$b[1],
                    joint.inter.b2 = summary(joint.test.interactive)$b[2],
                    joint.inter.b3 = summary(joint.test.interactive)$b[3],
                    joint.inter.b.se = summary(joint.test.interactive)$b[4],
                    joint.inter.b2.se = summary(joint.test.interactive)$b[5],
                    joint.inter.b3.se = summary(joint.test.interactive)$b[6],
                    joint.inter.p1 = summary(joint.test.interactive)$pval[1],
                    joint.inter.p2 = summary(joint.test.interactive)$pval[2],
                    joint.inter.p3 = summary(joint.test.interactive)$pval[3],
                    joint.inter.p.se = summary(joint.test.interactive)$pval[4],
                    joint.inter.p2.se = summary(joint.test.interactive)$pval[5],
                    joint.inter.p3.se = summary(joint.test.interactive)$pval[6]
                    )
  return(data.frame(out))
  }




#Step 4: Process your documentation
#Now you need to create the documentation from your annotations earlier. You’ve already done the “hard” work in Step 3. Step 4 is as easy doing this:

setwd("./cats")
document()
#This automatically adds in the .Rd files to the man directory, and adds a NAMESPACE file to the main directory. You can read up more about these, but in terms of steps you need to take, you really don’t have to do anything further.


#Step 5: Install!
#Now it is as simple as installing the package! You need to run this from the parent working directory that contains the cats folder.

setwd("..")
install("cats")
#Now you have a real, live, functioning R package. For example, try typing ?cat_function. You should see the standard help page pop up!

#Step 6: Make the package a GitHub repo
# to putting your package onto GitHub is that you can use the devtools install_github() function to install your new package directly from the GitHub page.

install_github('cats','github_username')

```




